/* START */

// Scene sizes
var WINDOW_WIDTH							= window.innerWidth,
	WINDOW_HEIGHT							= window.innerHeight - 4;

// Camera settings
var ASPECT							= WIDTH / HEIGHT,
	VIEW_ANGLE						= 45,
	NEAR							= 0.1,
	FAR								= 1000;
ASPECT = 1.7778;
var WIDTH							= WINDOW_WIDTH,
	HEIGHT							= WIDTH / ASPECT;

// Global rendering variables
var renderer, camera, scene;
var objects							= [];

// Initialise stuff
function init() {
	// Rendering settings
	renderer							= new THREE.WebGLRenderer();
	camera								= new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene								= new THREE.Scene();

	// Add camera to the scene
	scene.add(camera);
	camera.position.y					= 1;
	camera.position.z					= 5;

	// Set renderer size
	renderer.setSize(WIDTH, HEIGHT);

	// Add the DOM element generated by the renderer to the html body
	document.body.appendChild(renderer.domElement);

	initLights();
	initObjects();

//	window.addEventListener('resize', onWindowResize, false);
}

function initLights() {
	// Point light
	var pointLight						= new THREE.PointLight(0xffffff);
	pointLight.position.x				= 0;
	pointLight.position.y				= 1;
	pointLight.position.z				= 3;
	scene.add(pointLight);
}

function initObjects() {
	// Box
	var geometry						= new THREE.CubeGeometry(7.2, 4, 2);
//	var material						= new THREE.MeshLambertMaterial({color: 0x449911});
	var material						= new THREE.MeshLambertMaterial({color: 0x449911, side: THREE.BackSide});
	objects['box']						= new THREE.Mesh(geometry, material);
	scene.add(objects['box']);
	objects['box'].position.y		= 1;

	// Sky dome
	var radius							= 100,
		hSegments						= 64,
		vSegments						= 16;
	var vertexShader					= document.getElementById('vertexShader').textContent,
		fragmentShader					= document.getElementById('fragmentShader').textContent;
	var uniforms						= {
		topColor	: {type: "c", value: new THREE.Color( 0x0077ff )},
		bottomColor	: {type: "c", value: new THREE.Color( 0xffffff )},
		offset		: {type: "f", value: 33},
		exponent	: {type: "f", value: 0.6}
	};
	var geometry						= new THREE.SphereGeometry(radius, hSegments, vSegments);
	var material						= new THREE.ShaderMaterial({vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide});
	objects['skyDome']					= new THREE.Mesh(geometry, material);
	scene.add(objects['skyDome']);

	// Paddle
	var geometry						= new THREE.CubeGeometry(0.5, 0.02, 0.2);
	var material						= new THREE.MeshLambertMaterial({color: 0x00ff00});
	objects['paddle']					= new THREE.Mesh(geometry, material);
	objects['']
	scene.add(objects['paddle']);

	// Ball
	var radius							= 0.05,
		hSegments						= 16,
		vSegments						= 16;
	var geometry						= new THREE.SphereGeometry(radius, hSegments, vSegments);
	var material						= new THREE.MeshPhongMaterial({color: 0xffaa55, specular: 0x888888, shininess: 200});
	objects['ball']						= new THREE.Mesh(geometry, material);
	objects['ball'].position.x			= 1;
	scene.add(objects['ball']);

//	initBricks();
	initNewBricks();
}



// New Bricks
function initNewBricks() {
	var gridWidth						= 0.3;

	objects['bricks']					= [];

	$.each(level[0].levelDesign, function(key, value) {

	});

}

// Bricks
function initBricks() {
	objects['bricks']					= [];
	var maxLength						= 6.4,
		maxLeft							= -maxLength / 2,
		maxRight						= maxLength / 2,							// currently unused
		maxTop							= 2.7,
		maxBottom						= 0,										// currently unused


		brickLength						= 0.3,
		brickBreadth					= 0.2,
		brickHeight						= 0.15,
		bricksPerCol					= Math.floor(maxLength / brickLength),

		xOffset							= brickLength + 0.01,
		yOffset							= brickHeight + 0.01,
		numBricks						= 53,

		rowOffset						= (maxLength - (brickLength * bricksPerCol)) / 2 + brickLength / 2,

		currX							= maxLeft + rowOffset,
		currY							= maxTop;

	var geometry						= new THREE.CubeGeometry(brickLength, brickHeight, brickBreadth);
	var material						= new THREE.MeshLambertMaterial({color: 0x55ff00});

	for (var i = 0; i < numBricks; i++) {
		var brick = new THREE.Mesh(geometry.clone(), material);
		scene.add(brick);
		if ((i != 0) && (i % bricksPerCol == 0)) {
			var bricksLeft				= numBricks - i;
			if (bricksLeft < bricksPerCol) {
				rowOffset				= (maxLength - (brickLength * bricksLeft)) / 2 + brickLength / 2;
				currX					= maxLeft + rowOffset;
			} else {
				currX					= maxLeft + rowOffset;
			}
			currY						-= yOffset;
		}
		brick.position.set(currX, currY, 0);
		currX							+= xOffset;

		objects['bricks'][i]			= brick;
	}
}

// Animation
function animate() {
	requestAnimationFrame(animate);
//	objects['paddle'].rotation.x		+= 0.01;
//	objects['paddle'].rotation.y		+= 0.02;
	render();
}

// Rendering
function render() {
	renderer.render(scene, camera);
}

init();
animate();

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );
}

/* END */