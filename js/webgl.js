/* START */

/**
 * BASE CODE:
 * ALL DONE
 *
 * POLISHING:
 * DONE: Performance stats
 * TODO: Game stats (lives, level, etc.)
 * TODO: Code optimisation
 * TODO: Code minification
 */

/* ==== */
/* MAIN */
/* ==== */

/* Global variables */

// Scene sizes
var WINDOW_WIDTH						= window.innerWidth,
	WINDOW_HEIGHT						= window.innerHeight - 4;

// Camera settings
var ASPECT								= WINDOW_WIDTH / WINDOW_HEIGHT,
	VIEW_ANGLE							= 45,
	NEAR								= 0.1,
	FAR									= 1000;

ASPECT = 1.7778;	// Manually overridden in order to keep the aspect ratio, which helps making the game look uniform

var WIDTH								= WINDOW_WIDTH,
	HEIGHT								= WIDTH / ASPECT;

// Rendering variables
var renderer, camera, scene, stats;
var objects								= [];
var mouse								= {};

var currLevel							= 0;

/* End global variables */

init();
animate();

/* ========= */
/* FUNCTIONS */
/* ========= */

// Initialise stuff
function init() {
	// Rendering settings
	renderer							= new THREE.WebGLRenderer();
	camera								= new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene								= new THREE.Scene();

	// Add camera to the scene
	scene.add(camera);
	camera.position.y					= 1;
	camera.position.z					= 5;

	// Set renderer size
	renderer.setSize(WIDTH, HEIGHT);

	// Add the DOM element generated by the renderer to the html body
	document.body.appendChild(renderer.domElement);

	// Stats
	stats								= new Stats();
	stats.domElement.style.position		= 'absolute';
	stats.domElement.style.top			= '20px';
	stats.domElement.style.left			= '20px';
	stats.domElement.style.zIndex		= '100';

	document.body.appendChild(stats.domElement);

	initLights();
	initObjects();

//	window.addEventListener('resize', onWindowResize, false);
	window.addEventListener('mousemove', trackPosition, true)
}

function initLights() {
	// Point light
	var pointLight						= new THREE.PointLight(0xffffff);
	pointLight.position.x				= 0;
	pointLight.position.y				= 1;
	pointLight.position.z				= 3;
	scene.add(pointLight);
}

function initObjects() {
	// Sky dome
	var radius							= 100,
		hSegments						= 64,
		vSegments						= 16;
	var vertexShader					= document.getElementById('vertexShader').textContent,
		fragmentShader					= document.getElementById('fragmentShader').textContent;
	var uniforms						= {
		topColor	: {type: "c", value: new THREE.Color( 0x0077ff )},
		bottomColor	: {type: "c", value: new THREE.Color( 0xffffff )},
		offset		: {type: "f", value: 33},
		exponent	: {type: "f", value: 0.6}
	};
	var geometry						= new THREE.SphereGeometry(radius, hSegments, vSegments);
	var material						= new THREE.ShaderMaterial({vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide});
	objects['skyDome']					= new THREE.Mesh(geometry, material);
	scene.add(objects['skyDome']);

//	initBricks();
	initNewBricks();

	initBalls();

	initPaddles();

	initWalls();
}

// Walls
function initWalls() {
	drawWalls();
}

function drawWalls() {
	var width							= 7.2,
		height							= 4,
		breadth							= 2,
		startPosX						= 0,
		startPosY						= 1;

	objects['walls']					= {type: "walls", objects: []};

	var wallsObj						= new Walls(startPosX, startPosY, width, height, breadth);
	wallsObj.draw();
	objects['walls'].objects.push(wallsObj);
}

function Walls(startPosX, startPosY, width, height, breadth) {
	this.leftWall						= startPosX - width / 2;
	this.rightWall						= startPosX + width / 2;
	this.topWall						= startPosY + height / 2;
	this.bottomWall						= startPosY - height / 2;

//	console.log(this.leftWall + " : " + this.rightWall + " : " + this.topWall);

	this.draw = function() {
		this.geometry					= new THREE.CubeGeometry(width, height, breadth);
		this.material					= new THREE.MeshLambertMaterial({color: 0x449911, side: THREE.BackSide});
		this.mesh						= new THREE.Mesh(this.geometry, this.material);
		this.mesh.position.set(startPosX, startPosY, 0);
		scene.add(this.mesh);
	}
}

// Paddles
function initPaddles() {
	drawPaddles();
}

function drawPaddles() {
	var width							= 0.5,
		height							= 0.02,
		breadth							= 0.2,
		startPosX						= -1,
		startPosY						= 0;

	objects['paddles']					= {type: "paddles", objects: []};

	var paddleObj						= new Paddle(startPosX, startPosY, width, height, breadth);
	paddleObj.draw();
	objects['paddles'].objects.push(paddleObj);
}

function Paddle(startPosX, startPosY, width, height, breadth) {
	this.width							= width;
	this.height							= height;
	this.breadth						= breadth;

	this.draw = function() {
		this.geometry					= new THREE.CubeGeometry(this.width, this.height, this.breadth);
		this.material					= new THREE.MeshPhongMaterial({color: 0xffaa55});
		this.mesh						= new THREE.Mesh(this.geometry, this.material);
		this.mesh.position.set(startPosX, startPosY, 0);
		scene.add(this.mesh);
	}

	this.update = function() {
		this.move();
	}

	this.move = function() {
		// Move with mouse

//		console.log(mouse.x);
		if (mouse.x && mouse.y) {
			this.mesh.position.x		= mouse.x;
//			console.log(mouse.x);
		}
	}
}

// Balls
function initBalls() {
	drawBalls();
}

function drawBalls() {
	var radius							= 0.05,
		hSegments						= 16,
		vSegments						= 16,
		startPosX						= 0,
		startPosY						= 0.75;

	objects['balls']					= {type: "balls", objects: []};

	var ballObj							= new Ball(radius, startPosX, startPosY, hSegments, vSegments);
	ballObj.draw();
	objects['balls'].objects.push(ballObj);
}

function Ball(radius, startPosX, startPosY, hSegments, vSegments) {
	this.baseVelX						= 0.01;
	this.baseVelY						= 0.03;
	this.velX							= this.baseVelX;
	this.velY							= this.baseVelY;
	this.radius							= radius;

	this.draw = function() {
		this.geometry					= new THREE.SphereGeometry(this.radius, hSegments, vSegments);
		this.material					= new THREE.MeshPhongMaterial({color: 0xffaa55, specular: 0x888888, shininess: 200});
		this.mesh						= new THREE.Mesh(this.geometry, this.material);
		this.mesh.position.set(startPosX, startPosY, 0);
		scene.add(this.mesh);
	}

	this.update = function() {
		this.move();
	}

	this.move = function() {
		this.mesh.position.x			+= this.velX;
		this.mesh.position.y			+= this.velY;

		var collisionStatus			= {};

		// Test collision against walls
		collisionStatus					= this.testCollision(objects['walls']);
		if (collisionStatus.x) {
			this.velX					*= -1;
		} if (collisionStatus.y) {
			this.velY					*= -1;
		}

		// Test against padels
		collisionStatus					= this.testCollision(objects['paddles']);
		if (collisionStatus) {
			this.velY					*= -1;
		}

		// Test against bricks
		collisionStatus					= this.testCollision(objects['bricks']);
		switch (collisionStatus) {
			case 'top':
			case 'bottom':
				this.velY				*= -1;
				break;

			case 'left':
			case 'right':
				this.velX				*= -1;
				break;
		}
	}

	this.testCollision = function(obj) {
		switch (obj.type) {
			// Test against walls
			case "walls":
				var collisionStatus		= {};

				if ((this.mesh.position.x  + this.radius) > obj.objects[0].rightWall
					|| (this.mesh.position.x  - this.radius) < obj.objects[0].leftWall)
				{
					collisionStatus.x	= true;
				}

				if ((this.mesh.position.y + this.radius) > obj.objects[0].topWall
					|| (this.mesh.position.y  - this.radius) < obj.objects[0].bottomWall)
				{
					collisionStatus.y	= true;
				}
				return collisionStatus;
				break;

			// Test against paddles
			case "paddles":
					// Check whether the ball is below the paddle (approximate calculation, which is sufficient for the
					// current velocity
				if ((this.mesh.position.y - this.radius) < obj.objects[0].mesh.position.y

					// So that the ball doesn't get in the weird state of collisions when below the paddle but also
					// within its length
					&& this.mesh.position.y > (obj.objects[0].mesh.position.y - 0.1)

					// Check whether the ball is within the length of the paddle
					&& this.mesh.position.x > (obj.objects[0].mesh.position.x - obj.objects[0].width / 2)
					&& this.mesh.position.x < (obj.objects[0].mesh.position.x + obj.objects[0].width / 2))
				{
					var velXChange		= (this.mesh.position.x - obj.objects[0].mesh.position.x) / (obj.objects[0].width / 2);
					this.velX			= this.baseVelX * (velXChange);
					return true;
				}

				break;

			// Test agains bricks
			case "bricks":
				// Save the reference to the current ball object, since 'this' won't refer to it inside the forEach loop
				var ballObj				= this,
					updatedBricks		= [],
					collisionStatus		= {},
					collisionThreshold	= 0.05;
				obj.objects.forEach(function(brick, i){
					// Check collision with the bottom edge of the brick
					if (ballObj.mesh.position.x > brick.posXMin
						&& ballObj.mesh.position.x < brick.posXMax
						&& ballObj.mesh.position.y < brick.posYMin
						&& (ballObj.mesh.position.y + collisionThreshold) > brick.posYMin
						&& ballObj.mesh.position.y < brick.posYMax)
					{
//						collisionStatus.bottomEdge	= true;
						collisionStatus	= "bottom";
						scene.remove(brick.mesh);
					}
					// Check collision with the top edge of the brick
					else if (ballObj.mesh.position.x > brick.posXMin
						&& ballObj.mesh.position.x < brick.posXMax
						&& ballObj.mesh.position.y > brick.posYMin
						&& ballObj.mesh.position.y > brick.posYMax
						&& (ballObj.mesh.position.y - collisionThreshold) < brick.posYMax)
					{
//						collisionStatus.topEdge	= true;
						collisionStatus	= "top";
						scene.remove(brick.mesh);
					}

					// Check collision with the left edge of the brick
					else if (ballObj.mesh.position.y > brick.posYMin
						&& ballObj.mesh.position.y < brick.posYMax
						&& ballObj.mesh.position.x < brick.posXMin
						&& (ballObj.mesh.position.x + collisionThreshold) > brick.posXMin
						&& ballObj.mesh.position.x < brick.posXMax)
					{
//						collisionStatus.leftEdge	= true;
						collisionStatus	= "left";
						scene.remove(brick.mesh);
					}
					// Check collision with the right edge of the brick
					else if (ballObj.mesh.position.y > brick.posYMin
						&& ballObj.mesh.position.y < brick.posYMax
						&& ballObj.mesh.position.x > brick.posXMin
						&& ballObj.mesh.position.x > brick.posXMax
						&& (ballObj.mesh.position.x - collisionThreshold) < brick.posXMax)
					{
//						collisionStatus.rightEdge	= true;
						collisionStatus	= "right";
						scene.remove(brick.mesh);
					}
					// No collision detected - add the current brick to the updated list of bricks to be rendered
					else {
						updatedBricks.push(brick);
					}

					/*if (ballObj.mesh.position.y > brick.posYMin
						&& ballObj.mesh.position.y < brick.posYMax
						&& ballObj.mesh.position.x > brick.posXMin
						&& ballObj.mesh.position.x < brick.posXMax)
					{
//						console.log("HIT!!!: " + i);
						brick.wireframeMaterial.color.setHex(0xff99cc);
						scene.remove(brick.mesh);
					} else {
						updatedBricks.push(brick);
					}*/

				});

				obj.objects				= updatedBricks;
				return collisionStatus;
				break;

			default:
				break;
		}
	}
}

// New Bricks
function initNewBricks() {
	var bricks = [];

	// Use 'for' loop if performance is poor
	level[currLevel].levelDesign.forEach(function (row, i) {
		if (row != "") {
			bricks.push(tokenise(row));
		} else {
			bricks.push("");
		}
	});

	drawBricks(bricks);
}

/* This utility function will send back a row in the following format:
row = [
	['', 1],
	['a',3],	// format: 'brick type', length
	...
];
*/
function tokenise(str) {
	var row = [],
		currBrickLen = 1;
	for (i = 0, len = str.length; i < len; i++) {
		if (str[i] == str[i + 1]) {
			currBrickLen++;

		} else {
			currBrickType = str[i];
			var brick = [currBrickType, currBrickLen];
			row.push(brick);
			currBrickLen = 1;
		}
	}
	return row;
}

function drawBricks(bricks) {
	var startTop						= 2.7,
		startLeft						= -3.2,

		gridWidth						= 0.3,
		gridHeight						= 0.15,
		gridBreadth						= 0.2,

		gridPaddingX					= 0.05,		// not needed right now as edge-face rendering is segregating bricks nicely
		gridPaddingY					= 0.01,		// not needed right now as edge-face rendering is segregating bricks nicely

		// to compensate for the fact that the grid's local axes are center aligned to the grid, instead of left and top
		offsetX							= gridWidth / 2,
		offsetY							= gridHeight / 2,

		totalRows						= bricks.count,
		currRow							= 0;

	objects['bricks']					= {type: "bricks", objects: []};

	bricks.forEach(function(row, i) {

		if (row == "") {
			currRow++;
		} else {
			var localStartLeft			= startLeft,
				posX					= localStartLeft,
				posY					= startTop - (gridHeight * currRow),
				currCol					= 0,
				currBrick				= 0;

			row.forEach(function(brick, j) {
				if (brick[0] != " ") {

					var brickWidth		= (brick[1] * gridWidth),
						brickHeight		= gridHeight,
						brickBreadth	= gridBreadth;

					var offsetX			= brickWidth / 2;
//						posX			= offsetX +  startLeft + (gridWidth * currCol) + (gridPaddingX * currBrick);
						// posX			= posX + offsetX + 0.3;
//						posX			= (posX / 2) + (brickWidth / 2);
						// posX			= posX + brickWidth / 2;
					posX				= localStartLeft + offsetX;

					localStartLeft		= posX + offsetX;

					var brickObj		= new Brick(brick, posX, posY, brickWidth, brickHeight, brickBreadth);
					brickObj.draw();
					objects['bricks'].objects.push(brickObj);

//					currCol				+= brick[1];
//					currBrick++;
				} else {
//					currCol++;

					var blankBrickWidth	= brick[1] * gridWidth;
					var offsetX			= blankBrickWidth / 2;
					posX				= localStartLeft + offsetX
					localStartLeft		= posX + offsetX;
				}
			});
			currRow++;
		}
	});
}

function Brick(brick, posX, posY, brickWidth, brickHeight, brickBreadth) {
	this.type							= brick[0].toLowerCase();
	this.width							= brickWidth;
	this.height							= brickHeight;
	this.breadth						= 0.2;
	this.color							= level[currLevel].brickTypes[this.type];

	this.posXMin						= posX - this.width / 2;
	this.posXMax						= posX + this.width / 2;
	this.posYMin						= posY - this.height / 2;
	this.posYMax						= posY + this.height / 2;

//	console.log(this.posYMin + " : " + posY + " : " + this.posYMax);

	this.draw = function () {
		if (this.type != " ") {
			this.geometry				= new THREE.CubeGeometry(this.width, this.height, this.breadth);

//			this.material				= new THREE.MeshLambertMaterial({color: this.color});
//			this.brickMesh				= new THREE.Mesh(this.geometry, this.material);

			this.darkMaterial			= new THREE.MeshLambertMaterial({color: this.color});
			this.wireframeMaterial		= new THREE.MeshBasicMaterial({color: 0x000000, wireframe: true, transparent: true});
			this.multiMaterial			= [this.darkMaterial, this.wireframeMaterial];
			this.mesh					= THREE.SceneUtils.createMultiMaterialObject(this.geometry, this.multiMaterial);

			// this.geometry.applyMatrix(new THREE.Matrix4().setTranslation(0.3, 0, 0));
//			console.log(posX + " " + posY);
//			console.log(this.color);
			this.mesh.position.set(posX, posY,0 );
			scene.add(this.mesh);
		}
	};
}

// Bricks
/*function initBricks() {
	objects['bricks']					= [];
	var maxLength						= 6.4,
		maxLeft							= -maxLength / 2,
		maxRight						= maxLength / 2,							// currently unused
		maxTop							= 2.7,
		maxBottom						= 0,										// currently unused


		brickLength						= 0.3,
		brickBreadth					= 0.2,
		brickHeight						= 0.15,
		bricksPerCol					= Math.floor(maxLength / brickLength),

		xOffset							= brickLength + 0.01,
		yOffset							= brickHeight + 0.01,
		numBricks						= 53,

		rowOffset						= (maxLength - (brickLength * bricksPerCol)) / 2 + brickLength / 2,

		currX							= maxLeft + rowOffset,
		currY							= maxTop;

	var geometry						= new THREE.CubeGeometry(brickLength, brickHeight, brickBreadth);
	var material						= new THREE.MeshLambertMaterial({color: 0x55ff00});

	for (var i = 0; i < numBricks; i++) {
		var brick = new THREE.Mesh(geometry.clone(), material);

		scene.add(brick);
		if ((i != 0) && (i % bricksPerCol == 0)) {
			var bricksLeft				= numBricks - i;
			if (bricksLeft < bricksPerCol) {
				rowOffset				= (maxLength - (brickLength * bricksLeft)) / 2 + brickLength / 2;
				currX					= maxLeft + rowOffset;
			} else {
				currX					= maxLeft + rowOffset;
			}
			currY						-= yOffset;
		}
		brick.position.set(currX, currY, 0);
		currX							+= xOffset;

		objects['bricks'][i]			= brick;
	}
}*/

// Animation
function animate() {
	requestAnimationFrame(animate);
	update();
	render();
}

function update() {
//	objects['paddles'][0].mesh.rotation.x		+= 0.01;
//	objects['paddles'][0].mesh.rotation.y		+= 0.02;
//	objects['balls'][0].mesh.position.x			+= objects['balls'][0].velX;
	objects['balls'].objects[0].update();
	objects['paddles'].objects[0].update();
	stats.update();
}

// Rendering
function render() {
	renderer.render(scene, camera);
}

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );
}

function trackPosition(e) {
	var x								= (e.clientX/WIDTH) * 2 - 1,
		y								= (e.clientY/HEIGHT) * 2 + 1;
	var vector							= new THREE.Vector3(x, y, 0.5);

	// Get a ray pointing in the direction of the mouse pointer from the camera
	var projector						= new THREE.Projector();
	projector.unprojectVector(vector, camera);

	var dir								= vector.sub(camera.position).normalize();

	// Extend the ray from the camera, until the z-coordinate of the tip of the ray is zero
	var ray								= new THREE.Raycaster(camera.position, dir);
	var distance						= -camera.position.z / dir.z;

	// Store the position of mouse as a point in 3D space, and in the plane z = 0
	var pos								= camera.position.clone().add(dir.multiplyScalar(distance));
	mouse.x								= pos.x;
	mouse.y								= pos.y;
}

/* END */